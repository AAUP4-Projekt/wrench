use crate::frontend::ast::Expr;
use crate::frontend::ast::Operator;
use crate::frontend::ast::Statement;
use crate::frontend::ast::TypeConstruct;
use crate::frontend::ast::Declaration;
use crate::frontend::ast::Misc;
use crate::frontend::lexer::Token;



// This beings the grammer definition used by lalrpop
grammar;

// External definitions for the grammar

extern {
    // Type used to track token positions
    type Location = usize;

    // Mapping lexer tokens to the grammar's internal Token enum, so they can be used in grammar
    enum Token {

        // Character operators
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "**" => Token::Expon,
        "/" => Token::Slash,
        "!" => Token::ExclamationMark,
        "%" => Token::Modulo,
        "==" => Token::EqualsOperator,

        // Values
        Stringliteral => Token::Stringliteral(<String>),
        DoubleLiteral => Token::Doubleliteral(<f64>),
        Integer => Token::Integer(<i32>),
        "true" => Token::True,
        "false" => Token::False,

        // Identifier
        Identifier => Token::Identifier(<String>),

        // Reserved keywords
        "skip" => Token::Skip,
        "while" => Token::While,
        "if" => Token::If,
        "else" => Token::Else,
        "var" => Token::Var,
        "const" => Token::Constant,
        "fn" => Token::Function,
        "return" => Token::Return,
        "for" => Token::For,
        "rpipe" => Token::Rpipe,
        "pipe" => Token::Pipe,
        "row" => Token::Row,
        "table" => Token::Table,
        "and" => Token::LogicalAnd,
        "or" => Token::LogicalOr,

        // Types
        "bool" => Token::Boolean,
        "int" => Token::IntegerKeyword,
        "double" => Token::DoubleKeyword,
        "string" => Token::String,
        "null" => Token::Null,

        // Special chars
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "(" => Token::Openparan,
        ")" => Token::Closeparan,
        "{" => Token::Opencurlybracket,
        "}" => Token::Closecurlybracket,
        "[" => Token::Opensquarebracket,
        "]" => Token::Closesquarebracket,
        "<" => Token::LeftAngle,
        ">" => Token::RightAngle,
        "?" => Token::QuestionMark,
        "$" => Token::Dollarsign,
        "=" => Token::AssignmentOperator,
    }
}

pub Program: Vec<Statement> = {
    // Match one or more statements
    <s:Stmt +> => s,
};

Stmt: Statement = {
    // Match a statement that consists of an expression followed by a semicolon
    <e:Expr> ";" => Statement::Expr(e),
    <e:Decl> ";" => Statement::Declaration(e), // Match a declaration followed by a semicolon
    <i:Identifier> "=" <e:Expr> ";" => Statement::VariableAssignment(i, e), // Variable assignment E.g. x = 5;
};

Decl: Declaration = {
    // Match variable declartions e.g. var int x = 5;
    "var" <t:Type> <i:Identifier> "=" <e:Expr> => Declaration::VariableDeclaration(t, i, e), // Variable declaration E.g. var int x = 5;
    // Match function declarations e.g. fn int add(int a, int b) { return a + b; }
    "fn" <t:Type> <i:Identifier> "(" <p:Params> ")" "{" <s:Stmt *> "}" => Declaration::FunctionDeclaration(t, i, p, s), // Function declaration E.g. fn int add(int a, int b) { return a + b; }
}


Params: Vec<Misc> = {
    // Match zero or more parameter declarations separated by commas
    <p:(Param ("," Param)*)?> => {
        p.map(|(first, rest)| {
            let mut params = vec![first];
            params.extend(rest.into_iter().map(|(_, param)| param));
            params
        }).unwrap_or_else(Vec::new)
    }
};

Param: Misc = {
    // Match a single parameter declaration
    <t:Type> <i:Identifier> => Misc::Parameter(t, i),
};


Type: TypeConstruct = {
    // Match the type keywords and map them to the corresponding enum variants
    "bool" => TypeConstruct::Bool,
    "int" => TypeConstruct::Int,
    "double" => TypeConstruct::Double,
    "string" => TypeConstruct::String,
    "null" => TypeConstruct::Null,
};

// Entry rule for expressions: This is the starting point of the grammar
// and defines the structure of valid expressions.
Expr: Box<Expr> = {
    #[precedence(level="0")] // Highest precedence
    TermExpr,

    #[precedence(level="1")] #[assoc(side="right")]
    <e:Expr> "**" <f:Expr> => Box::new(Expr::Operation(e, Operator::Exp, f)),

    #[precedence(level="2")] #[assoc(side="left")]
    <e:Expr> "*" <f:Expr> => Box::new(Expr::Operation(e, Operator::Mul, f)),

    // Match + or - expressions left-to-right associativity
    #[precedence(level="3")] #[assoc(side="left")]
    <e:Expr> "+" <f:Expr> => Box::new(Expr::Operation(e, Operator::Add, f)),
    <e:Expr> "-" <f:Expr> => Box::new(Expr::Operation(e, Operator::Sub, f)),
};

// Term represents the basic building blocks of expressions, such as numbers and parenthesized expressions
TermExpr: Box<Expr> = {
    // A literal number (e.g., 42) becomes Expr::Number(i32)
    Integer => Box::new(Expr::Number(<>)), 
    // An identifier
    Identifier => Box::new(Expr::Identifier(<>)),
    //True and false
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false)),
    // A parenthesized expression (e.g., (a + b)) is 
    "(" <Expr> ")"
};
