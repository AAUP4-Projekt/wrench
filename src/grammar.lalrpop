use crate::frontend::ast::Expr;
use crate::frontend::ast::Operator;
use crate::frontend::ast::Statement;
use crate::frontend::ast::TypeConstruct;
use crate::frontend::lexer::Token;

// This beings the grammer definition used by lalrpop
grammar;

// External definitions for the grammar
extern {
    // Type used to track token positions
    type Location = usize;

    // Mapping lexer tokens to the grammar's internal Token enum
    enum Token {
        Integer => Token::Integer(<i32>),
        Identifier => Token::Identifier(<String>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "**" => Token::Expon,
        "(" => Token::Openparan,
        ")" => Token::Closeparan,
        ";" => Token::Semicolon,
        "=" => Token::AssignmentOperator,
        "true" => Token::True,
        "false" => Token::False,
        "bool" => Token::Boolean,
        "int" => Token::IntegerKeyword,
        "double" => Token::DoubleKeyword,
        "string" => Token::String,
        "var" => Token::Var,
    }
}

pub Program: Vec<Statement> = {
    // Match one or more statements
    <s:Stmt +> => s,
};

pub Stmt: Statement = {
    // Match a statement that consists of an expression followed by a semicolon
    <e:Expr> ";" => Statement::Expr(e),
    // Match variable declartions e.g. var int x = 5;
    "var" <t:Type> <i:Identifier> "=" <e:Expr> ";" => Statement::VariableDeclaration(t, i, e), // Variable declaration E.g. var int x = 5;
    // Match variable assignment e.g. x = 5;
    <i:Identifier> "=" <e:Expr> ";" => Statement::VariableAssignment(i, e), // Variable assignment E.g. x = 5;
};

pub Type: TypeConstruct = {
    // Match the type keywords and map them to the corresponding enum variants
    "bool" => TypeConstruct::Bool,
    "int" => TypeConstruct::Int,
    "double" => TypeConstruct::Double,
    "string" => TypeConstruct::String,
};

// Entry rule for expressions: This is the starting point of the grammar
// and defines the structure of valid expressions.
Expr: Box<Expr> = {
    // Match + or - expressions left-to-right associativity
    <e:Expr> "+" <f:MulExpr> => Box::new(Expr::Operation(e, Operator::Add, f)),
    <e:Expr> "-" <f:MulExpr> => Box::new(Expr::Operation(e, Operator::Sub, f)),
    // OR just a factor (e.g., a)
    MulExpr,
};

// Factor rule handles the multiplication and division operations
MulExpr: Box<Expr> = {
    // Match * expression left-to-right associativity
    <e:MulExpr> "*" <f:ExpoExpr> => Box::new(Expr::Operation(e, Operator::Mul, f)),
    // Or just a term (e.g., a)
    ExpoExpr,
};

ExpoExpr: Box<Expr> = {
    // Match ** expression right-to-left associativity
    <e:TermExpr> "**" <f:ExpoExpr> => Box::new(Expr::Operation(e, Operator::Exp, f)),
    // Or just a term (e.g., a)
    TermExpr,
};

// Term represents the basic building blocks of expressions, such as numbers and parenthesized expressions
TermExpr: Box<Expr> = {
    // A literal number (e.g., 42) becomes Expr::Number(i32)
    Integer => Box::new(Expr::Number(<>)), 
    // An identifier
    Identifier => Box::new(Expr::Identifier(<>)),
    //True and false
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false)),
    // A parenthesized expression (e.g., (a + b)) is 
    "(" <Expr> ")"
};
