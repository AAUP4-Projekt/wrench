use crate::frontend::ast::Expr;
use crate::frontend::ast::Opcode;
use crate::frontend::lexer::Token;

// This beings the grammer definition used by lalrpop
grammar;

// External definitions for the grammar
extern {
    // Custom error type for the parser (Currently a placeholder)
    //type Error = ();

    // Type used to track token positions
    type Location = usize;

    // Mapping lexer tokens to the grammar's internal Token enum
    enum Token {
        Number => Token::IntegerNumber(<i32>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
    }
}

// Entry rule for expressions: This is the starting point of the grammar
// and defines the structure of valid expressions.
pub Expr: Box<Expr> = {
    // Match an expression with an operator and a factor (e.g., a + b)
    Expr ExprOp Factor => Box::new(Expr::Op(<>)),
    // OR just a factor (e.g., a)
    Factor,
};

//ExprOp is used to define the operators that can be used between expressions
ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

// Factor rule handles the multiplication and division operations
Factor: Box<Expr> = {
    // Match a factor with an operator and a term (e.g., a * b)
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    // Or just a term (e.g., a)
    Term,
};

// FactorOp defines the operators that can be used between factors
FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

// Term represents the basic building blocks of expressions, such as numbers and parenthesized expressions
Term: Box<Expr> = {
    // A literal number (e.g., 42) becomes Expr::Number(i32)
    Number => Box::new(Expr::Number(<>)), 
    // A parenthesized expression (e.g., (a + b)) is 
    "(" <Expr> ")"
};
